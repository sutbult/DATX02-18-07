<!DOCTYPE html>
<html>

<head>
  <title>Compile and Deploy</title>
  <link rel="stylesheet" href="libs/mui.min.css">
</head>

<body>
  <header class="mui-appbar"></header>

  <section class="mui-container-fluid"> 
    <div class="mui-row">
      <div class="mui-col-md-6">
        <div class="mui-select">
          <select id="versions"></select>
        </div>
      </div> 
    </div>
  </section>
  <div class="mui-container" style="float: left;">
    <p id="status" style="float: right; margin-top:20px"></p>
  </div>
  <div clas="mui-container">
  <label for="secret" class="col-lg-2 control-label">Secret</label>
    <input id="secret" type="text">

  <label for="dest" class="col-lg-2 control-label">Destination</label>
    <input id="dest" type="text">

    
  <label for="ether" class="col-lg-2 control-label">Amount of ether to send</label>
    <input id="ether" type="text">
  </div>

  <div class="mui-row">
    <div class="mui-col-md-6">
      <div class="mui-panel">
        <p style="font-size:25px; font-weight:bold">
          Compile Contract
        </p>
        <textarea id="source" onclick="this.select()" 
        style="height: 360px; width: 530px; display: block; margin-left: 20px;">
        pragma solidity ^0.4.18;

        contract HTLC {
        
            string public version = "0.0.1";
            bytes32 public digest;
            address public dest;
            uint public timeOut = now + 1 hours;
            address issuer = msg.sender;
        
            modifier onlyIssuer {require(msg.sender == issuer); _; }
        
            event Claim(string _hash);
        
            function HTLC(bytes32 _digest, address _dest) public payable {
                digest = _digest;
                dest = _dest;
        
            }
        
            //a string is subitted that is hash tested to the digest; If true the funds are sent to the dest address and destroys the contract
            function claim(string _hash) public returns(bool result) {
               require(digest == keccak256(_hash));
               Claim(_hash);
               selfdestruct(dest);
               return true;
               }
        
            // allow payments
            function () public payable {}
        
            //if the time expires; the issuer can reclaim funds and destroy the contract
            function refund() onlyIssuer public returns(bool result) {
                require(now >= timeOut);
                selfdestruct(issuer);
                return true;
            }
        }
        </textarea>
        <button id="contract-compile"  class="mui-btn mui-btn--primary">
          Compile
        </button>
        <button id="contract-deploy"  class="mui-btn mui-btn--primary">
          Deploy
        </button>
      </div>
    </div>
  </div> 
  <div clas="mui-container">
      <label for="key" class="col-lg-2 control-label">Secret</label>
        <input id="key" type="text">
      <label for="adrForHTLC" class="col-lg-2 control-label">Address to contract</label>
        <input id="adrForHTLC" type="text">
        <button id="htlc-unlock"  class="mui-btn mui-btn--primary">
          Unlock
        </button>
  </div>




  <script src="libs/mui.min.js" type="text/javascript"></script>
  <script src="libs/solc.min.js" type="text/javascript"></script>
  <script src="libs/web3.min.js" type="text/javascript"></script>
  <script src="compile.js" type="text/javascript"></script>

  <script>
    
    web3FirstChain = new Web3(new Web3.providers.HttpProvider('http://localhost:7545'));
    web3SecondChain = new Web3(new Web3.providers.HttpProvider('http://localhost:8545'));
    console.log(web3FirstChain.isConnected());
    console.log(web3SecondChain.isConnected());
    var abi;//JSON.parse()
    var gContract;
    //This is only needed when you try to claim, so only needed on web3SecondChain
    //web3FirstChain.eth.defaultAccount = web3FirstChain.eth.coinbase;
    var accounts = []    
    web3FirstChain.eth.getAccounts((err,acc) => {
        console.log(acc);
        accounts.push(acc);
    });

    //this function gets called by addDeployEvent() when you press the deploy btn
    function prepareAndDeploy(){
      var bytecode = '0x'+compiledContract.contracts[":HTLC"].bytecode; //hardcoded specifying htl-contract
      abi = JSON.parse(compiledContract.contracts[":HTLC"].interface);
      var p_digest = web3FirstChain.sha3(document.getElementById('secret').value);
      var p_dest = document.getElementById('dest').value;//"0xd513156a649ee0112a721ea9b4ea92ee7beb5ffd";
      var ether = web3FirstChain.toWei(document.getElementById('ether').value, "ether");//web3FirstChain.toWei(10,"ether");

      var contract = web3FirstChain.eth.contract(abi);
      let gasEstimate =  4712386;//web3FirstChain.eth.estimateGas({data: bytecode});
      var contractInstance = contract.new(p_digest,p_dest, {data: bytecode,gas: gasEstimate,from: web3FirstChain.eth.coinbase, value: ether});
      gContract = contractInstance;
      waitBlock(contractInstance);
    }

    function addDeployEvent(){
      const deployBtn = document.getElementById('contract-deploy');
      deployBtn.addEventListener('click', prepareAndDeploy);
    }

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    // wait until any miner has included the transaction
    // in a block to get the address of the contract
    async function waitBlock(contract) {
      while (true) {
        let receipt = web3FirstChain.eth.getTransactionReceipt(contract.transactionHash);
        if (receipt && receipt.contractAddress) {
          console.log("Contract deployed at " + receipt.contractAddress);
          addEvent();
          break;
        }
        console.log("Waiting for a mined block to include your contract... currently in block " + web3FirstChain.eth.blockNumber);
        await sleep(4000);
      }
    }
    
    function unlock(){
      
      web3SecondChain.eth.defaultAccount = web3SecondChain.eth.coinbase;
      let contract = web3SecondChain.eth.contract(abi);
      let contractInstance = contract.at(document.getElementById('adrForHTLC').value);
      console.log(contractInstance);
      let _hash = document.getElementById('key').value;
      
      contractInstance.claim(_hash);
    }

    function addEvent(){
      console.log("Here");
      var claimEvent = gContract.Claim();
      
      claimEvent.watch(function(error,result) {
        //TODO: add automated unlock here!
        if(!error){
          console.log("The secret is " + result.args._hash.toString());
          //This is hardcoded for my second account 
          console.log(web3FirstChain.fromWei(web3FirstChain.eth.getBalance('0xd513156a649ee0112a721ea9b4ea92ee7beb5ffd')).c["0"]);
        } else {
          console.log(error);
        }
      });
    }

    function addUnlockEvent(){
      const unlockBtn = document.getElementById('htlc-unlock');
      unlockBtn.addEventListener('click', unlock);
    }







  </script>

</body>

</html>